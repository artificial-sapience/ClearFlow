from dataclasses import dataclass
from typing import Any

from _typeshed import Incomplete
from dspy.dsp.utils.settings import settings as settings
from dspy.utils.callback import BaseCallback as BaseCallback

@dataclass
class StreamResponse:
    predict_name: str
    signature_field_name: str
    chunk: str
    is_last_chunk: bool

@dataclass
class StatusMessage:
    message: str

def sync_send_to_stream(stream, message): ...

class StatusMessageProvider:
    def tool_start_status_message(self, instance: Any, inputs: dict[str, Any]): ...
    def tool_end_status_message(self, outputs: Any): ...
    def module_start_status_message(self, instance: Any, inputs: dict[str, Any]): ...
    def module_end_status_message(self, outputs: Any): ...
    def lm_start_status_message(self, instance: Any, inputs: dict[str, Any]): ...
    def lm_end_status_message(self, outputs: Any): ...

class StatusStreamingCallback(BaseCallback):
    status_message_provider: Incomplete
    def __init__(self, status_message_provider: StatusMessageProvider | None = None) -> None: ...
    def on_tool_start(self, call_id: str, instance: Any, inputs: dict[str, Any]): ...
    def on_tool_end(self, call_id: str, outputs: dict[str, Any] | None, exception: Exception | None = None): ...
    def on_lm_start(self, call_id: str, instance: Any, inputs: dict[str, Any]): ...
    def on_lm_end(self, call_id: str, outputs: dict[str, Any] | None, exception: Exception | None = None): ...
    def on_module_start(self, call_id: str, instance: Any, inputs: dict[str, Any]): ...
    def on_module_end(self, call_id: str, outputs: dict[str, Any] | None, exception: Exception | None = None): ...
