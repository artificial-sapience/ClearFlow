from typing import Any

from _typeshed import Incomplete
from dspy.signatures.field import InputField as InputField
from dspy.signatures.field import OutputField as OutputField
from pydantic import BaseModel
from pydantic._internal._model_construction import ModelMetaclass
from pydantic.fields import FieldInfo

class SignatureMeta(ModelMetaclass):
    def __call__(cls, *args, **kwargs): ...
    def __new__(mcs, signature_name, bases, namespace, **kwargs): ...
    @property
    def instructions(cls) -> str: ...
    @instructions.setter
    def instructions(cls, instructions: str) -> None: ...
    @property
    def input_fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def output_fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def signature(cls) -> str: ...

class Signature(BaseModel, metaclass=SignatureMeta):
    @classmethod
    def with_instructions(cls, instructions: str) -> type[Signature]: ...
    @classmethod
    def with_updated_fields(cls, name: str, type_: type | None = None, **kwargs: dict[str, Any]) -> type[Signature]: ...
    @classmethod
    def prepend(cls, name, field, type_=None) -> type[Signature]: ...
    @classmethod
    def append(cls, name, field, type_=None) -> type[Signature]: ...
    @classmethod
    def delete(cls, name) -> type[Signature]: ...
    @classmethod
    def insert(cls, index: int, name: str, field, type_: type | None = None) -> type[Signature]: ...
    @classmethod
    def equals(cls, other) -> bool: ...
    @classmethod
    def dump_state(cls): ...
    @classmethod
    def load_state(cls, state): ...

def ensure_signature(signature: str | type[Signature], instructions=None) -> type[Signature]: ...
def make_signature(signature: str | dict[str, tuple[type, FieldInfo]], instructions: str | None = None, signature_name: str = "StringSignature", custom_types: dict[str, type] | None = None) -> type[Signature]: ...
def infer_prefix(attribute_name: str) -> str: ...
